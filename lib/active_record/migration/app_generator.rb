# frozen_string_literal: true

module ActiveRecord
  class Migration
    #
    # Run app migrations generated by Admin::MigrationGenerator.
    # This relies on the generated migrations setting attributes in the migration
    # file, which are then used to decide what to actually run.
    # NOTE: changes to this file require the app server to be restarted.
    # @todo document methods
    module AppGenerator
      extend ActiveSupport::Concern

      included do
        attr_accessor :fields, :new_fields, :field_defs, :prev_fields,
                      :field_opts, :owner, :history_table_id_attr,
                      :belongs_to_model, :history_table_name, :trigger_fn_name,
                      :table_comment, :fields_comments, :db_configs, :mode, :no_master_association,
                      :requested_action, :resource_type, :prev_table_name, :view_sql, :all_referenced_tables,
                      :class_name
      end

      def force_rollback
        ENV['FORCE_ROLLBACK'] == 'true' && reverting?
      end

      def schema=(new_schema)
        unless Admin::MigrationGenerator.current_search_paths.include?(new_schema)
          raise FphsException, "Current search_path does not include the schema (#{new_schema}) for the migration. " \
                               "#{Admin::MigrationGenerator.current_search_paths}"
        end

        @schema = new_schema
      end

      def schema
        @schema
      end

      def table_name=(tname)
        @table_name = tname
        self.history_table_name = Admin::MigrationGenerator.history_table_name_for tname
        self.history_table_id_attr = Admin::MigrationGenerator.history_table_id_attr_for tname
      end

      def table_name
        @table_name
      end

      def create_schema
        return if schema_exists?(schema)

        sql = "CREATE SCHEMA IF NOT EXISTS #{schema}"
        sql += " AUTHORIZATION #{owner}" if owner.present? && !Rails.env.development?
        ActiveRecord::Base.connection.execute sql
      end

      def add_fields_to_tables
        setup_fields

        add_fields "#{schema}.#{table_name}"
        add_fields "#{schema}.#{history_table_name}"
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def rand_id
        Digest::MD5.hexdigest("#{schema}.#{table_name}")[0..7]
      end

      def create_or_update_activity_log_tables
        self.requested_action = :create_or_update
        self.resource_type = :activity_log

        if table_exists
          update_fields
        else
          create_activity_log_tables
        end
      end

      def create_activity_log_tables
        setup_fields

        self.belongs_to_model = belongs_to_model.to_s.underscore

        parent_model_is_view = Admin::MigrationGenerator.view_exists?(belongs_to_model.pluralize.to_s)

        unless table_exists
          create_table "#{schema}.#{table_name}", comment: table_comment do |t|
            t.belongs_to :master, index: { name: "#{rand_id}_master_id_idx" }, foreign_key: true

            # Views can not be referenced by foreign keys
            if parent_model_is_view
              t.integer "#{belongs_to_model}_id"
            else
              t.belongs_to belongs_to_model,
                           index: { name: "#{rand_id}_id_idx" },
                           foreign_key: { to_table: belongs_to_model.pluralize.to_s }
            end
            create_fields t
            t.string :extra_log_type
            t.references :user, index: { name: "#{rand_id}_user_id_idx" }, foreign_key: true
            t.timestamps null: false
          end
        end

        unless history_table_exists || model_is_view
          create_table "#{schema}.#{history_table_name}" do |t|
            t.belongs_to :master, index: { name: "#{rand_id}_master_id_h_idx" }, foreign_key: true

            # Views can not be referenced by foreign keys
            if parent_model_is_view
              t.integer "#{belongs_to_model}_id"
            else
              t.belongs_to belongs_to_model,
                           index: { name: "#{rand_id}_id_h_idx" },
                           foreign_key: { to_table: belongs_to_model.pluralize.to_s }
            end
            create_fields t, true
            t.string :extra_log_type
            t.references :user, index: { name: "#{rand_id}_user_id_h_idx" }, foreign_key: true
            t.timestamps null: false

            t.belongs_to table_name.singularize, index: { name: "#{rand_id}_b_id_h_idx" },
                                                 foreign_key: { to_table: "#{schema}.#{table_name}" }
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def create_reference_views
        done = []
        reversible do |dir|
          dir.up do
            all_referenced_tables.each do |ref_config|
              to_table_name = ref_config[:to_table_name]
              next if to_table_name.in? done

              done << to_table_name
              puts "-- create or replace reference view #{ref_view_name(to_table_name)}"
              refsql = reference_view_sql(ref_config)
              unless refsql
                puts "No reference view sql generated for #{to_table_name} view #{ref_view_name(to_table_name)}"
                next
              end

              ActiveRecord::Base.connection.execute refsql
            end
          end
          dir.down do
            all_referenced_tables.each do |ref_config|
              to_table_name = ref_config[:to_table_name]
              next if to_table_name.in? done

              done << to_table_name
              puts "-- drop function #{ref_view_name(to_table_name)}"
              refsql = reverse_reference_view_sql(ref_config)
              next unless refsql

              ActiveRecord::Base.connection.execute refsql
            end
          end
        end
      end

      def create_activity_log_trigger
        setup_fields(fields & col_names(:sym))

        reversible do |dir|
          dir.up do
            puts "-- create or replace function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute activity_log_trigger_sql
          end
          dir.down do
            puts "-- drop function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute reverse_activity_log_trigger_sql
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def create_or_update_dynamic_model_tables
        self.requested_action = :create_or_update
        self.resource_type = :dynamic_model

        if table_exists
          update_fields
        else
          create_dynamic_model_tables
        end
      end

      def create_dynamic_model_tables
        setup_fields

        unless table_exists
          create_table "#{schema}.#{table_name}", comment: table_comment do |t|
            unless no_master_association
              t.belongs_to :master, index: {
                name: "dmbt_#{rand_id}_id_idx"
              }, foreign_key: true
            end
            create_fields t
            t.references :user, index: true, foreign_key: true
            t.timestamps null: false
          end

        end
        unless history_table_exists || model_is_view
          create_table "#{schema}.#{history_table_name}" do |t|
            unless no_master_association
              t.belongs_to :master, index: { name: "#{rand_id}_history_master_id" }, foreign_key: true
            end
            create_fields t, true
            t.references :user, index: { name: "#{rand_id}_user_idx" }, foreign_key: true
            t.timestamps null: false

            t.belongs_to table_name.singularize, index: { name: "#{rand_id}_id_idx" },
                                                 foreign_key: { to_table: "#{schema}.#{table_name}" }
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def create_dynamic_model_trigger
        return unless history_table_exists && !model_is_view

        setup_fields(fields & col_names(:sym))

        reversible do |dir|
          dir.up do
            puts "-- create or replace function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute dynamic_model_trigger_sql
          end
          dir.down do
            puts "-- drop function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute reverse_dynamic_model_trigger_sql
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def create_or_update_dynamic_model_view
        self.requested_action = :create_or_update
        self.resource_type = :dynamic_model

        create_dynamic_model_view
        change_comments
      end

      def create_dynamic_model_view
        reversible do |dir|
          dir.up do
            puts "-- create or replace view #{schema}.#{table_name}"
            ActiveRecord::Base.connection.execute dynamic_model_view_sql
          end
          dir.down do
            puts "-- drop view #{schema}.#{table_name}"
            ActiveRecord::Base.connection.execute reverse_dynamic_model_view_sql
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def create_or_update_external_identifier_tables(id_field, id_field_type = :bigint)
        self.requested_action = :create_or_update
        self.resource_type = :external_identifier

        if table_exists
          update_fields
        else
          create_external_identifier_tables(id_field, id_field_type)
        end
      end

      def create_external_identifier_tables(id_field, id_field_type = :bigint)
        self.fields ||= []
        self.fields.unshift id_field
        self.fields = fields.uniq
        setup_fields

        field_defs[id_field] = id_field_type

        unless table_exists
          create_table "#{schema}.#{table_name}", comment: table_comment do |t|
            t.belongs_to :master, index: { name: "ei#{rand_id}_id_idx" }, foreign_key: true
            create_fields t
            t.references :user, index: true, foreign_key: true
            t.references :admin, index: true, foreign_key: true
            t.timestamps null: false
          end
        end
        unless history_table_exists || model_is_view
          create_table "#{schema}.#{history_table_name}" do |t|
            t.belongs_to :master, index: { name: "eih#{rand_id}_id_idx" }, foreign_key: true
            create_fields t, true
            t.references :user, index: true, foreign_key: true
            t.references :admin, index: true, foreign_key: true
            t.timestamps null: false

            t.belongs_to "#{table_name.singularize}_table", index: { name: "#{table_name.singularize}_id_idx" },
                                                            foreign_key: { to_table: "#{schema}.#{table_name}" }
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def create_external_identifier_trigger(_id_field)
        return if history_table_exists || model_is_view

        self.fields ||= []
        # self.fields.unshift id_field
        self.fields = fields.uniq
        setup_fields(fields & col_names(:sym))

        reversible do |dir|
          dir.up do
            puts "-- create or replace function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute external_identifier_trigger_sql
          end
          dir.down do
            puts "-- drop function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute reverse_external_identifier_trigger_sql
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def update_table_name
        rename_table prev_table_name, table_name
        rename_table Admin::MigrationGenerator.history_table_name_for(prev_table_name),
                     Admin::MigrationGenerator.history_table_name_for(table_name)

        # Drop the trigger, so that it can be recreated with a new name
        reversible do |dir|
          dir.up do
            puts "-- drop function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute "DROP FUNCTION IF EXISTS #{calc_trigger_fn_name(prev_table_name)}() CASCADE"
          end
          dir.down do
            puts "-- drop function #{trigger_fn_name}"
            ActiveRecord::Base.connection.execute "DROP FUNCTION IF EXISTS #{calc_trigger_fn_name(table_name)}() CASCADE"
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def table_exists
        Admin::MigrationGenerator.table_or_view_exists? "#{schema}.#{table_name}"
      end

      def model_is_view
        Admin::MigrationGenerator.view_exists? "#{schema}.#{table_name}"
      end

      def history_table_exists
        ActiveRecord::Base.connection.schema_cache.clear!
        ActiveRecord::Base.connection.table_exists? "#{schema}.#{history_table_name}"
      end

      def update_fields
        self.mode = :update
        self.db_configs ||= {}

        belongs_to_model_field = "#{belongs_to_model}_id" if belongs_to_model

        col_names = if reverting?
                      prev_col_names
                    else
                      self.col_names
                    end
        col_names ||= []

        old_colnames = col_names - standard_columns
        old_history_colnames = if history_table_exists
                                 history_col_names - standard_columns
                               else
                                 []
                               end
        new_colnames = fields.map(&:to_s) - standard_columns
        added = (new_colnames - old_colnames - [belongs_to_model_field]).reject { |a| a.to_s.index(ignore_fields) }
        removed = (old_colnames - new_colnames - [belongs_to_model_field]).reject { |a| a.to_s.index(ignore_fields) }

        changed = {}
        db_configs.each do |k, v|
          current_type = cols.find { |c| c.name == k.to_s }&.type
          next unless v[:type] && current_type

          expected_type = (v[:type]&.to_sym || :string)
          current_type = :timestamp if current_type == :datetime
          expected_type = :timestamp if expected_type == :datetime
          puts "Type change (#{k}): #{current_type} != #{expected_type}" if current_type != expected_type
          changed[k.to_s] = expected_type if current_type != expected_type
        end

        added_history = (new_colnames - old_history_colnames - [belongs_to_model_field]).reject do |a|
          a.to_s.index(ignore_fields)
        end
        removed_history = (old_history_colnames - new_colnames - [belongs_to_model_field]).reject do |a|
          a.to_s.index(ignore_fields)
        end

        changed_history = {}
        if history_table_exists
          db_configs.each do |k, v|
            current_type = history_cols.find { |c| c.name == k.to_s }&.type
            next unless v[:type] && current_type

            expected_type = (v[:type]&.to_sym || :string)
            current_type = :timestamp if current_type == :datetime
            expected_type = :timestamp if expected_type == :datetime
            puts "Type change (#{k}): #{current_type} != #{expected_type}" if current_type != expected_type
            changed_history[k.to_s] = expected_type if current_type != expected_type
          end
        end

        idx = added.index('created_by_user_id')
        added[idx] = 'created_by_user' if idx
        if history_table_exists
          idx = added_history.index('created_by_user_id')
          added_history[idx] = 'created_by_user' if idx
        end

        idx = removed.index('created_by_user_id')
        removed[idx] = 'created_by_user' if idx
        if history_table_exists
          idx = removed_history.index('created_by_user_id')
          removed_history[idx] = 'created_by_user' if idx
        end

        if reverting?
          puts 'Rollback'
          puts "Adding: #{removed &= col_names}"
          puts "Removing: #{added -= col_names}"
          puts "Adding (history): #{removed_history &= history_col_names}" if history_table_exists
          puts "Removing (history): #{added_history -= history_col_names}" if history_table_exists
        else
          puts 'Migrate'
          puts "Adding: #{added -= col_names}"
          puts "Removing: #{removed &= col_names}"
          puts "Changing: #{changed}"
          puts "Adding (history): #{added_history -= history_col_names}" if history_table_exists
          puts "Removing (history): #{removed_history &= history_col_names}" if history_table_exists
          puts "Changing (history): #{changed_history}"
        end

        if Rails.env.production? && (removed.present? || removed_history.present?) && ENV['ALLOW_DROP_COLUMNS'] != 'true'
          puts 'Specify "allow drop columns" is required to actually remove the columns - dropped columns will be ignored'
          removed = []
          removed_history = []
        end

        full_field_list = (old_colnames + new_colnames + col_names).uniq.map(&:to_sym)
        setup_fields(full_field_list)

        self.fields_comments ||= {}

        # Skip updates to missing history tables
        unless history_table_exists
          puts 'HISTORY TABLE does not exist'
          added_history = []
          removed_history = []
        end

        # If there was an activity log referencing this table, drop it, then recreate it at the end
        view_tn = table_name.sub(/^activity_log_/, 'al_')
        view_name = "#{view_tn}_from_al_%"
        reference_views = Admin::MigrationGenerator.view_definitions(schema, view_name)
        reference_views&.each do |view|
          execute <<~END_SQL
            DROP VIEW #{view['schemaname']}.#{view['viewname']};
          END_SQL
        end

        if belongs_to_model && !old_colnames.include?(belongs_to_model) && !col_names.include?(belongs_to_model_field)
          begin
            add_reference "#{schema}.#{table_name}", belongs_to_model, index: { name: "#{rand_id}_bt_id_idx" }
          rescue StandardError, ActiveRecord::StatementInvalid
            nil
          end
        end

        if no_master_association && !reverting? && col_names.include?('master_id')

          remove_reference "#{schema}.#{table_name}", :master
          remove_reference "#{schema}.#{history_table_name}", :master
          skip_master = true

        elsif !no_master_association && !reverting? && !col_names.include?('master_id')
          add_reference "#{schema}.#{table_name}", :master,
                        index: {
                          name: "dmbt_#{rand_id}_id_idx"
                        }, foreign_key: true

          add_reference "#{schema}.#{history_table_name}", :master,
                        index: {
                          name: "#{rand_id}_history_master_id"
                        },
                        foreign_key: true
          skip_master = true
        end

        added.each do |c|
          options = field_opts[c.to_sym] || {}
          comment = fields_comments[c.to_sym]
          options[:comment] = comment if comment.present?
          fdef = field_defs[c.to_sym]

          # If we are rolling back, skip this one unless the col name exists in the table
          # or if migrating up, skip this one unless the col name does not exist in the table
          next unless reverting? && c.in?(col_names) || !reverting? && !c.in?(col_names)

          if fdef == :references
            begin
              alt_c = options[:attr_name]
              add_reference "#{schema}.#{table_name}", alt_c, options
            rescue StandardError, ActiveRecord::StatementInvalid => e
              puts "******* Failed adding reference: #{schema}.#{table_name}, #{alt_c}, #{options}\n#{e}\n#{e.backtrace.join("\n")}"
              nil
            end
          else
            add_column "#{schema}.#{table_name}", c, fdef, options
          end
        end

        removed.each do |c|
          options = field_opts[c.to_sym] || {}
          comment = fields_comments[c.to_sym]
          options[:comment] = comment if comment.present?
          fdef = field_defs[c.to_sym] || {}

          # If we are rolling back, skip this one unless the col name does not exist in the table
          # or if migrating up, skip this one unless the col name exists in the table
          next unless reverting? && !c.in?(col_names) || !reverting? && c.in?(col_names)

          # Special case

          next if skip_master && c.to_sym == :master_id

          if fdef == :references
            alt_c = options[:attr_name]
            remove_reference "#{schema}.#{table_name}", alt_c, options
          else
            remove_column "#{schema}.#{table_name}", c, fdef
          end
        end

        if history_table_exists
          added_history.each do |c|
            options = field_opts[c.to_sym] || {}
            comment = fields_comments[c.to_sym]
            options[:comment] = comment if comment.present?
            fdef = field_defs[c.to_sym]

            # If we are rolling back, skip this one unless the col name exists in the table
            # or if migrating up, skip this one unless the col name does not exist in the table
            next unless reverting? && c.in?(history_col_names) || !reverting? && !c.in?(history_col_names)

            if fdef == :references
              options[:index][:name] += '_hist'
              begin
                add_reference "#{schema}.#{history_table_name}", c, options
              rescue StandardError, ActiveRecord::StatementInvalid
                nil
              end
            else
              add_column "#{schema}.#{history_table_name}", c, fdef, options
            end
          end

          removed_history.each do |c|
            options = field_opts[c.to_sym] || {}
            comment = fields_comments[c.to_sym]
            options[:comment] = comment if comment.present?
            fdef = field_defs[c.to_sym] || {}

            # If we are rolling back, skip this one unless the col name does not exist in the table
            # or if migrating up, skip this one unless the col name exists in the table
            next unless reverting? && !c.in?(history_col_names) || !reverting? && c.in?(history_col_names)

            if fdef == :references
              options[:index][:name] += '_hist'
              begin
                remove_reference "#{schema}.#{history_table_name}", c, options if c.in? history_col_names
              rescue StandardError, ActiveRecord::StatementInvalid
                nil
              end
            elsif c.in? history_col_names
              remove_column "#{schema}.#{history_table_name}", c, fdef
            end
          end
        end

        changed.each do |k, v|
          v = map_migration_type_to_db_type(v)
          change_type = "#{v} using #{k}::#{v}"
          change_column "#{schema}.#{table_name}", k, change_type
        end

        if history_table_exists
          changed_history.each do |k, v|
            v = map_migration_type_to_db_type(v)
            change_type = "#{v} using #{k}::#{v}"
            change_column "#{schema}.#{table_name}", k, change_type
          end
        end

        # Recreate the activity log reference views
        reference_views&.each do |view|
          new_view_sql = view['definition'].dup
          new_view_sql = new_view_sql.gsub(/dest\..+,\n/, "--removed-col\n")
          new_view_sql = new_view_sql.sub('--removed-col', 'dest.*,')
          new_view_sql = new_view_sql.gsub(/--removed-col.*\n/, '')
          execute <<~END_SQL
            create view #{view['schemaname']}.#{view['viewname']} as
            #{new_view_sql}
          END_SQL
        end

        change_comments
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def change_comments
        return unless table_exists

        setup_fields

        old_table_comment = ActiveRecord::Base.connection.table_comment(table_name)

        if old_table_comment != table_comment
          if model_is_view
            puts "Adding view comment: #{old_table_comment} != #{table_comment}"
            ActiveRecord::Base.connection.execute <<~END_SQL
              COMMENT ON VIEW #{schema}.#{table_name} IS '#{table_comment}';
            END_SQL
          else
            puts 'Adding table comment'
            change_table_comment("#{schema}.#{table_name}", table_comment)
          end
        end

        self.fields_comments ||= {}
        commented_colnames = fields_comments.keys.map(&:to_s)

        commented_colnames.each do |c|
          # puts "---->#{c} #{fields_comment[c.to_sym]}"
          # next unless fields_comments.key?(c.to_sym)

          col = cols.find { |csel| csel.name.to_s == c.to_s }
          puts 'Column not found!' unless col
          new_comment = fields_comments[c.to_sym]

          # Check if the existing comment matches the new comment. If it does skip the update
          next if !col || col&.comment == new_comment

          change_column_comment "#{schema}.#{table_name}", c, new_comment
          change_column_comment "#{schema}.#{history_table_name}", c, new_comment if history_table_exists
        end
      end

      protected

      #
      # Map migration type (symbol) to a real database type
      # to be used in SQL (such as alter table alter column DDL)
      # @param [Symbol] mig_type
      # @return [String]
      def map_migration_type_to_db_type(mig_type)
        case mig_type
        when :datetime
          'timestamp'
        when :string
          'varchar'
        when :references
          'integer'
        else
          mig_type.to_s
        end
      end

      def ignore_fields
        /^placeholder_|^embedded_report_|^tracker_history_id$|^id$/
      end

      def standard_columns
        pset = %w[id created_at updated_at contactid user_id tracker_history_id]
        pset += %w[master_id extra_log_type] if resource_type == :activity_log
        pset += %w[master_id admin_id] if resource_type == :external_identifier
        pset += %w[master_id] if resource_type == :dynamic_model && !no_master_association

        pset += ["#{table_name.singularize}_table_id", history_table_id_attr.to_s]
        pset
      end

      def cols
        ActiveRecord::Base.connection.columns("#{schema}.#{table_name}")
      end

      def history_cols
        ActiveRecord::Base.connection.columns("#{schema}.#{history_table_name}")
      end

      def history_col_names(to_type = nil)
        res = history_cols.map(&:name)
        res = res.map(&:to_sym) if to_type == :sym
        res
      end

      # The previous column names were either specified when initializing this
      # instance, or if in create_or_update mode then use the current table columns
      def prev_col_names(to_type = nil)
        res = if requested_action == :create_or_update
                Admin::MigrationGenerator.table_column_names table_name
              else
                prev_fields
              end

        if to_type == :sym
          res.map(&:to_sym)
        else
          res.map(&:to_s)
        end
      end

      def col_names(to_type = nil)
        res = cols.map(&:name)
        res = res.map(&:to_sym) if to_type == :sym
        res
      end

      def calc_trigger_fn_name(table_name)
        "#{schema}.log_#{table_name}_update"
      end

      def setup_fields(handle_fields = nil)
        self.fields_comments ||= {}

        return if field_opts && !handle_fields

        handle_fields ||= self.fields
        handle_fields.reject! { |a| a.to_s.index(ignore_fields) }
        handle_fields = handle_fields.map(&:to_sym)

        self.trigger_fn_name = calc_trigger_fn_name(table_name)
        self.new_fields = fields.map { |f| "NEW.#{f}" }
        self.field_defs = {}
        self.field_opts = {}
        self.db_configs ||= {}

        handle_fields.each do |attr_name|
          a = attr_name.to_s
          f = :string
          fopts = nil
          field_config = db_configs[attr_name]
          if field_config.present?
            # Field definition overrides everything else
            f = field_config[:type]
            fopts = {}
            fopts[:default] = field_config[:default] if field_config[:default]
            fopts[:index] = field_config[:index] if field_config[:index]
          elsif a == 'created_by_user_id'
            f = :references
            fopts = { index: { name: "#{rand_id}_ref_cb_user_idx" }, foreign_key: { to_table: :users }, attr_name: :created_by_user }
            attr_name = :created_by_user
          elsif a.index(/(?:_when|_date)$/)
            f = :date
          elsif a.index(/(?:_time)$/)
            f = :time
          elsif a.index(/(?:_at)$/)
            f = :timestamp
          elsif a.index(/^(?:select_record_id_from_)$/)
            f = :integer
          elsif a.index(/^(?:select_)|^(?:notes|data)$|(?:_name)$/)
            f = :string
          elsif a.index(/^(?:is_|has_)|(?:_check|_bool)$/)
            f = :boolean
          elsif a.index(/(?:_id)$/)
            f = :bigint
          elsif a.index(/^(?:number)|^(?:age|rank)$|(?:_number|_timestamp|score|_count)$/)
            f = :integer
          elsif a == 'disabled'
            f = :boolean
            fopts = { default: false }
          end
          field_defs[attr_name] = f

          # Add in a field comment if one is defined
          comment = fields_comments[attr_name.to_sym]
          if comment
            fopts ||= {}
            fopts[:comment] = comment
          end

          if field_config.present? && field_config[:array]
            fopts[:array] = field_config[:array]
          elsif a.start_with?('tag_select') || a.start_with?('multi_')
            fopts ||= {}
            fopts[:array] = true
          end

          field_opts[attr_name] = fopts
        end
      end

      def create_fields(tbl, history = nil)
        curr_field = {}
        field_defs.each do |attr_name, f|
          fopts = field_opts[attr_name]
          curr_field = {
            attr_name: attr_name,
            config: f,
            fopts: fopts
          }
          if fopts && fopts[:index]
            fopts[:index][:name] += '_hist' if history
            tbl.send(f, attr_name, **fopts)
          elsif fopts
            tbl.send(f, attr_name, **fopts)
          else
            tbl.send(f, attr_name)
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        puts "Failed to create field in table #{tbl.name}: #{curr_field}"
        puts "History table? #{!!history}"
        puts "All requested fields: #{field_defs}"
        raise e unless force_rollback
      end

      def add_fields(tbl)
        field_defs.each do |attr_name, f|
          fopts = field_opts[attr_name]
          if fopts
            add_column(tbl, attr_name, f, fopts)
          else
            add_column(tbl, attr_name)
          end
        end
      rescue StandardError, ActiveRecord::StatementInvalid => e
        raise e unless force_rollback
      end

      def updating?
        mode == :update
      end

      def creating?
        !updating?
      end

      def activity_log_trigger_sql
        base_name_id = "#{belongs_to_model.to_s.underscore.gsub(%r{__|/}, '_')}_id"
        <<~DO_TEXT
          CREATE OR REPLACE FUNCTION #{trigger_fn_name} ()
            RETURNS TRIGGER
            LANGUAGE plpgsql
            AS $$
          BEGIN
            INSERT INTO #{history_table_name} (
              master_id,
              #{base_name_id},
              #{"#{fields.join(', ')}," if fields.present?}
              extra_log_type,
              user_id,
              created_at,
              updated_at,
              #{history_table_id_attr})
            SELECT
              NEW.master_id,
              NEW.#{base_name_id},
              #{"#{new_fields.join(', ')}," if fields.present?}
              NEW.extra_log_type,
              NEW.user_id,
              NEW.created_at,
              NEW.updated_at,
              NEW.id;
            RETURN NEW;
          END;
          $$;

          DROP FUNCTION IF EXISTS #{schema}.log_#{table_name.singularize}_update () CASCADE;
          DROP TRIGGER IF EXISTS log_#{history_table_name}_insert ON #{schema}.#{table_name};
          DROP TRIGGER IF EXISTS log_#{history_table_name}_update ON #{schema}.#{table_name};

          CREATE TRIGGER log_#{history_table_name}_insert
            AFTER INSERT ON #{schema}.#{table_name}
            FOR EACH ROW
            EXECUTE PROCEDURE #{trigger_fn_name} ();

          CREATE TRIGGER log_#{history_table_name}_update
            AFTER UPDATE ON #{schema}.#{table_name}
            FOR EACH ROW
            WHEN ((OLD.* IS DISTINCT FROM NEW.*))
            EXECUTE PROCEDURE #{trigger_fn_name} ();

        DO_TEXT
      end

      def reverse_activity_log_trigger_sql
        if updating?
          activity_log_trigger_sql
        else
          "DROP FUNCTION #{trigger_fn_name}() CASCADE"
        end
      end

      def ref_view_name(to_table_name)
        tn = table_name.sub('activity_log_', 'al_')
        ttn = to_table_name.sub('activity_log_', 'al_')
        "#{ttn}_from_#{tn}"
      end

      def reference_view_sql(ref_config)
        return if ref_config[:without_reference]

        to_table_name = ref_config[:to_table_name]
        to_schema_name = ref_config[:to_schema_name]
        to_schema_table = [to_schema_name, to_table_name].compact.join('.')
        to_model_class_name = ref_config[:to_model_class_name]
        to_no_master = ref_config[:no_master_association]
        from_what = ref_config[:from]

        return if Admin::MigrationGenerator.view_exists?("#{schema}.#{ref_view_name(to_table_name)}")

        <<~DO_TEXT
          DROP VIEW if exists #{schema}.#{ref_view_name(to_table_name)};
          CREATE VIEW #{schema}.#{ref_view_name(to_table_name)} AS
          select
            dest.*,
            mr.from_record_master_id,
            mr.from_record_type, mr.from_record_id,
            mr.id model_reference_id,
            '#{to_schema_table}'::varchar from_table
          from #{to_schema_table} dest
          inner join model_references mr on
            dest.id = mr.to_record_id and
            #{to_no_master ? '' : 'dest.master_id = mr.to_record_master_id and'}
            not coalesce (mr.disabled, false) and
            #{from_what == 'this' ? "mr.from_record_type = '#{class_name}' and" : ''}
            mr.to_record_type = '#{to_model_class_name}'
          ;

        DO_TEXT
      end

      def reverse_reference_view_sql(ref_config)
        to_table_name = ref_config[:to_table_name]
        if updating?
          reference_view_sql(ref_config)
        else
          "DROP VIEW #{schema}.#{ref_view_name(to_table_name)};"
        end
      end

      def dynamic_model_view_sql
        return unless view_sql&.strip&.present?

        <<~DO_TEXT
          DROP VIEW if exists #{schema}.#{table_name};
          CREATE VIEW #{schema}.#{table_name} AS
          #{view_sql};
        DO_TEXT
      end

      def reverse_dynamic_model_view_sql
        if updating?
          dynamic_model_view_sql
        else
          "DROP VIEW #{schema}.#{table_name};"
        end
      end

      def dynamic_model_trigger_sql
        <<~DO_TEXT

          CREATE OR REPLACE FUNCTION #{trigger_fn_name} ()
            RETURNS TRIGGER
            LANGUAGE plpgsql
            AS $$
          BEGIN
            INSERT INTO #{history_table_name} (
              #{no_master_association ? '' : 'master_id,'}
              #{"#{fields.join(', ')}," if fields.present?}
              user_id,
              created_at,
              updated_at,
              #{history_table_id_attr})
            SELECT
              #{no_master_association ? '' : 'NEW.master_id,'}
              #{"#{new_fields.join(', ')}," if fields.present?}
              NEW.user_id,
              NEW.created_at,
              NEW.updated_at,
              NEW.id;
            RETURN NEW;
          END;
          $$;

          DROP TRIGGER IF EXISTS log_#{history_table_name}_insert ON #{schema}.#{table_name};
          DROP TRIGGER IF EXISTS log_#{history_table_name}_update ON #{schema}.#{table_name};

          CREATE TRIGGER log_#{history_table_name}_insert
            AFTER INSERT ON #{schema}.#{table_name}
            FOR EACH ROW
            EXECUTE PROCEDURE #{trigger_fn_name} ();

          CREATE TRIGGER log_#{history_table_name}_update
            AFTER UPDATE ON #{schema}.#{table_name}
            FOR EACH ROW
            WHEN ((OLD.* IS DISTINCT FROM NEW.*))
            EXECUTE PROCEDURE #{trigger_fn_name} ();

        DO_TEXT
      end

      def reverse_dynamic_model_trigger_sql
        if updating?
          dynamic_model_trigger_sql
        else
          "DROP FUNCTION #{trigger_fn_name}() CASCADE"
        end
      end

      def external_identifier_trigger_sql
        <<~DO_TEXT

          CREATE OR REPLACE FUNCTION #{trigger_fn_name} ()
            RETURNS TRIGGER
            LANGUAGE plpgsql
            AS $$
          BEGIN
            INSERT INTO #{history_table_name} (
              master_id,
              #{"#{fields.join(', ')}," if fields.present?}
              user_id,
              admin_id,
              created_at,
              updated_at,
              #{table_name.singularize}_table_id)
            SELECT
              NEW.master_id,
              #{"#{new_fields.join(', ')}," if fields.present?}
              NEW.user_id,
              NEW.admin_id,
              NEW.created_at,
              NEW.updated_at,
              NEW.id;
            RETURN NEW;
          END;
          $$;

          DROP TRIGGER IF EXISTS log_#{history_table_name}_insert ON #{schema}.#{table_name};
          DROP TRIGGER IF EXISTS log_#{history_table_name}_update ON #{schema}.#{table_name};

          CREATE TRIGGER log_#{history_table_name}_insert
            AFTER INSERT ON #{schema}.#{table_name}
            FOR EACH ROW
            EXECUTE PROCEDURE #{trigger_fn_name} ();

          CREATE TRIGGER log_#{history_table_name}_update
            AFTER UPDATE ON #{schema}.#{table_name}
            FOR EACH ROW
            WHEN ((OLD.* IS DISTINCT FROM NEW.*))
            EXECUTE PROCEDURE #{trigger_fn_name} ();

        DO_TEXT
      end

      def reverse_external_identifier_trigger_sql
        if updating?
          external_identifier_trigger_sql
        else
          "DROP FUNCTION #{trigger_fn_name}() CASCADE"
        end
      end
    end
  end
end
