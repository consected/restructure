# frozen_string_literal: true

require 'rails_helper'
require './db/table_generators/dynamic_models_table'

# Describe how dynamic model options work, especially with versioning
RSpec.describe 'Dynamic Model Options', type: :model do
  include MasterSupport
  include ModelSupport
  include PlayerContactSupport
  include BulkMsgSupport
  include DynamicModelSupport
  include OptionsSupport

  let :dynamic_type do
    'DynamicModel::TestCreatedByRec'
  end

  before :example do
    @user0, = create_user
    create_admin
    create_user
    setup_access :trackers
    setup_access :tracker_history
  end

  it 'gets the correct version of extra options based on creation date of the instance' do
    # NOTE: timestamps are compared after rounding down with .to_i to ensure that
    # the difference between the updated_at time generated by Rails and returned by the DB
    # do not cause unnecessary failures to be reported

    @def_updated_at = []
    @dyn_instances = []
    @option_texts = []
    @option_configs = []

    # Setup a simple dynamic model definition without any extra options
    # It will gain db column configurations pulled from the table definition
    dmdef = generate_test_dynamic_model
    @option_texts[1] = <<~END_CONFIG
      _db_columns:
        id:
          type: integer
        master_id:
          type: integer
        test1:
          type: string
        test2:
          type: string
        created_by_user_id:
          type: integer
        use_def_version_time:
          type: time
        text_array:
          type: string
          array: true
        user_id:
          type: integer
        created_at:
          type: datetime
        updated_at:
          type: datetime

    END_CONFIG

    @def_updated_at[1] = dmdef.updated_at

    # The option_configs retrieved directly from the current definition are always the current version
    @option_configs[1] = dmdef.option_configs

    # Create an instance of the dynamic model (v1)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[1] = @master.dynamic_model__test_created_by_recs.create! test1: 'abc'
    expect(@dyn_instances[1].class.to_s).to eq dynamic_type
    expect(@dyn_instances[1].class.definition).to eq dynamic_type.constantize.definition

    # The definition options should match the original
    expect(@dyn_instances[1].current_definition.options.strip).to eq @option_texts[1].strip
    expect(@dyn_instances[1].current_definition.option_configs).to eq @option_configs[1]

    # The dynamic model instance should pull options that matches the original v1 options
    check_version 1

    # Define some new option text and use it to update the definition as v2
    sleep 2 # ensure there are no timing issues
    @option_texts[2] = <<~END_DEF
      default:
        caption_before:
          all_fields: show before all fields
          test2: has a caption before test2
    END_DEF
    dmdef.update!(options: @option_texts[2], current_admin: @admin)
    @def_updated_at[2] = dmdef.updated_at
    @option_configs[2] = dmdef.option_configs

    # The updated dynamic model should contain the new options
    dmdef.reload
    expect(dmdef.options).to eq @option_texts[2]
    expect(dmdef.option_configs).to eq @option_configs[2]

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[2] = @master.dynamic_model__test_created_by_recs.create! test1: 'abc2'

    # Generate an instance to always use the latest version
    fixed_version = @master.dynamic_model__test_created_by_recs.create! test1: 'abc2', use_def_version_time: (DateTime.now + 99.years)

    ###
    # With a fixed version def *use_def_version_time* set, the correct version should be returned
    fixed_opt = option_configs_comparable(fixed_version.versioned_definition.option_configs)
    expect(fixed_opt).to eql option_configs_comparable(@option_configs[2])

    # The dynamic model instance should pull options that matches the original v1 options
    check_version 1

    # The new dynamic model instance should pull options text that matches the new v2 options text
    check_version 2

    # Define some new option text and use it to update the definition as v3
    sleep 2 # ensure there are no timing issues
    @option_texts[3] = <<~END_DEF
      default:
        caption_before:
          test2: has a caption before test2
          submit: new caption before submit
        labels:
          test1: test1 label
    END_DEF

    dmdef.update!(options: @option_texts[3], current_admin: @admin)
    @def_updated_at[3] = dmdef.updated_at
    @option_configs[3] = dmdef.option_configs

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[3] = @master.dynamic_model__test_created_by_recs.create! test1: 'abc3'

    check_version 3
    check_version 1
    check_version 2

    ###
    # With a fixed version def *use_def_version_time* set, the correct version should be returned
    expect(option_configs_comparable(fixed_version.versioned_definition.option_configs)).to eql option_configs_comparable(@option_configs[3])
  end

  it 'replaces option configurations' do
    unless Admin::MigrationGenerator.table_exists? 'test_created_by_recs'
      TableGenerators.dynamic_models_table('test_created_by_recs', :create_do, 'test1', 'test2', 'created_by_user_id')
    end

    name = 'test created by 2'
    dm = DynamicModel.create! current_admin: @admin,
                              name:,
                              table_name: 'test_created_by_recs',
                              schema_name: 'ml_app',
                              category: :test,
                              options: nil

    # Initially sets the options for db columns from the definition
    expect(dm.options).to eq <<~END_OPT
      _db_columns:
        id:
          type: integer
        master_id:
          type: integer
        test1:
          type: string
        test2:
          type: string
        created_by_user_id:
          type: integer
        user_id:
          type: integer
        created_at:
          type: datetime
        updated_at:
          type: datetime

    END_OPT

    hash = {
      _comments: nil
    }

    dm.prepend_to_options(hash)

    expect(dm.options).to eq <<~END_OPT
      _comments:#{' '}

      _db_columns:
        id:
          type: integer
        master_id:
          type: integer
        test1:
          type: string
        test2:
          type: string
        created_by_user_id:
          type: integer
        user_id:
          type: integer
        created_at:
          type: datetime
        updated_at:
          type: datetime

    END_OPT

    hash = {
      _db_columns: {
        id: { type: 'integer' },
        test1: { type: 'string' },
        test2: { type: 'string' }
      }
    }

    dm.prepend_to_options(hash)

    expect(dm.options).to eq <<~END_OPT
      _comments:#{' '}

      _db_columns:
        id:
          type: integer
        test1:
          type: string
        test2:
          type: string
    END_OPT

    dm.options = <<~END_OPT
      default:
        label: Something

    END_OPT

    expect(dm.options).to eq <<~END_OPT
      default:
        label: Something

    END_OPT

    hash = {
      _comments: nil
    }

    dm.prepend_to_options(hash)

    expect(dm.options).to eq <<~END_OPT
      _comments:#{' '}

      default:
        label: Something

    END_OPT

    hash = {
      _comments: {
        test1: 'A test comment'
      }
    }

    dm.prepend_to_options(hash)

    expect(dm.options).to eq <<~END_OPT
      _comments:
        test1: A test comment

      default:
        label: Something

    END_OPT

    hash = {
      _db_columns: {
        id: { type: 'integer' },
        test1: { type: 'string' },
        test2: { type: 'string' }
      }
    }

    dm.prepend_to_options(hash)

    expect(dm.options).to eq <<~END_OPT
      _db_columns:
        id:
          type: integer
        test1:
          type: string
        test2:
          type: string

      _comments:
        test1: A test comment

      default:
        label: Something

    END_OPT
  end

  it 'generates show_if from show_if_condition_strings' do
    dmdef = generate_test_dynamic_model
    opt = <<~END_CONFIG
      _db_columns:
        id:
          type: integer
        master_id:
          type: integer
        test1:
          type: string
        test2:
          type: string
        created_by_user_id:
          type: integer
        use_def_version_time:
          type: time
        text_array:
          type: string
          array: true
        user_id:
          type: integer
        created_at:
          type: datetime
        updated_at:
          type: datetime

      default:
        show_if_condition_strings:#{' '}
          user_id: '[test] <> "" and [test2] = "hello"'
        caption_before:
          all_fields: show before all fields
          test2: has a caption before test2
    END_CONFIG

    dmdef.update!(options: opt, current_admin: @admin)

    expect(dmdef.default_options.show_if[:user_id]).to be_a Hash

    expect(dmdef.default_options.show_if[:user_id]).to eq(
      all_0: {
        all_nonblock_0: {
          test: { condition: '<>', value: '' }
        },
        all_nonblock_1: { test2: 'hello' }
      }
    )
  end
end
