# frozen_string_literal: true

require 'rails_helper'
require './db/table_generators/activity_logs_table'

# Describe how dynamic model options work, especially with versioning
RSpec.describe 'Activity Log Options', type: :model do
  include MasterSupport
  include ModelSupport
  include PlayerContactSupport
  include ActivityLogSupport
  include OptionsSupport

  let :dynamic_type do
    ActivityLog::PlayerContactEmail
  end

  before :example do
    @user0, = create_user
    create_admin
    create_user
    setup_access :trackers
    setup_access :tracker_history
  end

  it 'gets the correct version of extra options based on creation date of the instance' do
    # NOTE: timestamps are compared after rounding down with .to_i to ensure that
    # the difference between the updated_at time generated by Rails and returned by the DB
    # do not cause unnecessary failures to be reported

    @def_updated_at = []
    @dyn_instances = []
    @option_texts = []
    @option_configs = []

    # Setup a simple dynamic model definition without any extra options
    dmdef = generate_test_activity_log
    @option_texts[1] = nil
    @def_updated_at[1] = dmdef.updated_at

    # The option_configs retrieved directly from the current definition are always the current version
    @option_configs[1] = dmdef.option_configs

    # Create an instance of the dynamic model (v1)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[1] = @master.activity_log__player_contact_emails.create! select_result: 'res1', extra_log_type: 'primary'
    expect(@dyn_instances[1]).to be_a dynamic_type

    # The definition options should match the original
    expect(@dyn_instances[1].current_definition.extra_log_types).to eq @option_texts[1]
    expect(@dyn_instances[1].current_definition.option_configs).to eq @option_configs[1]

    # The dynamic model instance should pull options that matches the original v1 options
    check_version 1

    # Define some new option text and use it to update the definition as v2
    sleep 2 # ensure there are no timing issues
    @option_texts[2] = <<~END_DEF
      new_step:
        label: New Step
        caption_before:
          all_fields: show before all fields
          select_result: has a caption before select_result
    END_DEF
    dmdef.update!(extra_log_types: @option_texts[2], current_admin: @admin)
    @def_updated_at[2] = dmdef.updated_at
    @option_configs[2] = dmdef.option_configs
    refresh_step_access dmdef

    # The updated dynamic model should contain the new options
    dmdef.reload
    expect(dmdef.extra_log_types).to eq @option_texts[2]
    expect(dmdef.option_configs).to eq @option_configs[2]

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[2] = @master.activity_log__player_contact_emails.create! select_result: 'res2', extra_log_type: 'new_step'

    # The dynamic model instance should pull options that matches the original v1 options
    check_version 1

    # The new dynamic model instance should pull options text that matches the new v2 options text
    check_version 2

    # Define some new option text and use it to update the definition as v3
    sleep 2 # ensure there are no timing issues
    @option_texts[3] = <<~END_DEF
      new_step:
        label: New Step
        caption_before:
          all_fields: show before all fields
          select_result: has a caption before select_result
      new_step2:
        label: New Step 2
        caption_before:
          all_fields: show before all fields
          select_result: has a caption before select_result
          notes: some notes
    END_DEF

    dmdef.update!(extra_log_types: @option_texts[3], current_admin: @admin)
    @def_updated_at[3] = dmdef.updated_at
    @option_configs[3] = dmdef.option_configs
    refresh_step_access dmdef

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[3] = @master.activity_log__player_contact_emails.create! select_result: 'res3', extra_log_type: 'new_step'
    check_version 3
    check_version 1
    check_version 2

    # Define some new option text and use it to update the definition as v4
    sleep 2 # ensure there are no timing issues
    @option_texts[4] = <<~END_DEF
      new_step:
        label: New Step
        caption_before:
          all_fields: show before all fields
          select_result: has a new caption before select_result
      new_step2:
        label: New Step 2
        caption_before:
          all_fields: show before all fields
          select_result: has another new caption before select_result
          notes: some notes
    END_DEF

    dmdef.update!(extra_log_types: @option_texts[4], current_admin: @admin)
    @def_updated_at[4] = dmdef.updated_at
    @option_configs[4] = dmdef.option_configs
    refresh_step_access dmdef

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[4] = @master.activity_log__player_contact_emails.create! select_result: 'res4', extra_log_type: 'new_step2'
    check_version 4
    check_version 2
    check_version 1
    check_version 3

    # Define some new option text and use it to update the definition as v5
    sleep 2 # ensure there are no timing issues
    @option_texts[5] = <<~END_DEF
      new_step:
        label: New Step
        caption_before:
          all_fields: show before all fields
          select_result: has a new caption before select_result
      new_step2:
        label: New Step 2
        caption_before:
          all_fields: show before all fields
          select_result: has another new caption before select_result
          notes: some more notes
    END_DEF

    dmdef.update!(extra_log_types: @option_texts[5], current_admin: @admin)
    @def_updated_at[5] = dmdef.updated_at
    @option_configs[5] = dmdef.option_configs
    refresh_step_access dmdef

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[5] = @master.activity_log__player_contact_emails.create! select_result: 'res5', extra_log_type: 'new_step2'
    check_version 5
    check_version 4
    check_version 2
    check_version 1
    check_version 3
  end

  it 'uses calc_if correctly for the appropriate definition version' do
    # NOTE: timestamps are compared after rounding down with .to_i to ensure that
    # the difference between the updated_at time generated by Rails and returned by the DB
    # do not cause unnecessary failures to be reported

    @def_updated_at = []
    @dyn_instances = []
    @option_texts = []
    @option_configs = []

    # Setup a simple dynamic model definition without any extra options
    dmdef = generate_test_activity_log
    @option_texts[1] = nil
    @def_updated_at[1] = dmdef.updated_at

    # The option_configs retrieved directly from the current definition are always the current version
    @option_configs[1] = dmdef.option_configs

    # Create an instance of the dynamic model (v1)
    sleep 2 # ensure there are no timing issues
    @dyn_instances[1] = @master.activity_log__player_contact_emails.create! select_result: 'res1', extra_log_type: 'primary'
    expect(@dyn_instances[1]).to be_a dynamic_type

    # The definition options should match the original
    expect(@dyn_instances[1].current_definition.extra_log_types).to eq @option_texts[1]
    expect(@dyn_instances[1].current_definition.option_configs).to eq @option_configs[1]

    # The dynamic model instance should pull options that matches the original v1 options
    check_version 1

    # Define some new option text and use it to update the definition as v2
    sleep 2 # ensure there are no timing issues
    @option_texts[2] = <<~END_DEF
      new_step:
        label: New Step
        caption_before:
          all_fields: show before all fields
          select_result: has a caption before select_result

        editable_if:
          all:
            this:
              select_result: 'good'
    END_DEF
    dmdef.update!(extra_log_types: @option_texts[2], current_admin: @admin)
    @def_updated_at[2] = dmdef.updated_at
    @option_configs[2] = dmdef.option_configs
    refresh_step_access dmdef

    expect(dmdef.option_type_config_for(:new_step).editable_if[:all][:this][:select_result]).to eq 'good'

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    al = @dyn_instances[2] = @master.activity_log__player_contact_emails.create! select_result: 'good', extra_log_type: 'new_step'

    expect(al.option_type_config.editable_if[:all][:this][:select_result]).to eq 'good'

    expect(al.can_edit?).to be_truthy

    al.update! select_result: 'bad'

    res = al.can_edit?
    expect(res).to be_falsey

    # Define some new option text and use it to update the definition as v3
    sleep 2 # ensure there are no timing issues
    @option_texts[3] = <<~END_DEF
      new_step:
        label: New Step
        caption_before:
          all_fields: show before all fields
          select_result: has a caption before select_result

        editable_if:
          all:
            this:
              select_result: 'bad'
    END_DEF
    dmdef.update!(extra_log_types: @option_texts[3], current_admin: @admin)
    @def_updated_at[3] = dmdef.updated_at
    @option_configs[3] = dmdef.option_configs
    refresh_step_access dmdef

    expect(dmdef.option_type_config_for(:new_step).editable_if[:all][:this][:select_result]).to eq 'bad'

    # The updated dynamic model should contain the new options
    dmdef.reload
    expect(dmdef.extra_log_types).to eq @option_texts[3]
    expect(dmdef.option_configs).to eq @option_configs[3]

    # Create an instance of the dynamic model (v2)
    sleep 2 # ensure there are no timing issues
    al = @dyn_instances[3] = @master.activity_log__player_contact_emails.create! select_result: 'bad', extra_log_type: 'new_step'
    expect(al.option_type_config.editable_if[:all][:this][:select_result]).to eq 'bad'

    expect(al.can_edit?).to be_truthy

    al.update! select_result: 'good'
    expect(al.can_edit?).to be_falsey

    # Expect the previous version still to be non-editable based on its definition (select_result: 'bad')
    expect(@dyn_instances[2].option_type_config.editable_if[:all][:this][:select_result]).to eq 'good'
    expect(@dyn_instances[2].can_edit?).to be_falsey

    @dyn_instances[2].force_save!
    @dyn_instances[2].update! select_result: 'good'
    expect(@dyn_instances[2].can_edit?).to be_truthy

    expect do
      al.update! select_result: 'good'
    end.to raise_error FphsException
  end

  it 'gets a full list of tables referenced by model references' do
    @def_updated_at = []
    @dyn_instances = []
    @option_texts = []
    @option_configs = []

    # Setup a simple dynamic model definition without any extra options
    dmdef = generate_test_activity_log
    @option_texts[1] = nil

    sleep 2 # ensure there are no timing issues
    @option_texts[4] = <<~END_DEF
      new_step:
        label: New Step
        caption_before:
          all_fields: show before all fields
          select_result: has a caption before select_result

        editable_if:
          all:
            this:
              select_result: 'bad'

        references:
          player_contact:
            from: this
          address:
            from: master
          activity_log__player_contact_email:
            from: this
          player_info:
            from: master
            without_reference: true
    END_DEF
    dmdef.update!(extra_log_types: @option_texts[4], current_admin: @admin)
    refresh_step_access dmdef

    res = dmdef.all_referenced_tables
    expect(res.length).to eq 4
    expect(res[0][:to_table_name]).to eq 'player_contacts'
    expect(res[0][:from]).to eq 'this'
    expect(res[1][:to_table_name]).to eq 'addresses'
    expect(res[1][:from]).to eq 'master'
    expect(res[2][:to_table_name]).to eq 'activity_log_player_contact_emails'
    expect(res[2][:from]).to eq 'this'
    expect(res[3][:to_table_name]).to eq 'player_infos'
    expect(res[3][:from]).to eq 'master'
    expect(res[3][:without_reference]).to eq true
  end
end
