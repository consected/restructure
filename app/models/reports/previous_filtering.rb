module Reports
  class PreviousFiltering
    FilterPreviousInnerSql =
      <<~END_SQL

        inner join (
          select id master_id from masters where id in (:filter_previous_ids)
        ) filter_previous_alias using(master_id)

      END_SQL
      .freeze

    attr_accessor :sql, :runner, :current_user, :sql_requests_filtering, :requested

    def initialize(runner)
      self.runner = runner
      self.current_user = runner.current_user
      self.sql = runner.sql
    end

    #
    # Handle the substitutions required for filter previous flags. There are two options:
    #  - :filter_previous - indicates that inner join SQL should be automatically inserted to handle the filtering
    #  - :ids_filter_previous - indicates that the SQL required for filtering is provided explicitly in the definition
    #                           and no addtional SQL substitutions should be made.
    # Filter previous functionality is only available if there is a current user, so an admin not logged in as a user can
    # not use the functionality.
    # @param [String] sql
    # @return [String] SQL with substitutions made (if necessary)
    def substitute_filter_previous(sql)
      if current_user && requested

        if sql.include?(':filter_previous') && filtering_ids
          # Substitute in inner join SQL to satisfy the filtering directly,
          # and handle the substitution of conditions with the id list
          clean_inner_sql = ActiveRecord::Base.send(:sanitize_sql_for_conditions,
                                                    [
                                                      FilterPreviousInnerSql,
                                                      { filter_previous_ids: filtering_ids }
                                                    ])

          sql = sql.gsub(':filter_previous', clean_inner_sql) if clean_inner_sql

          self.sql_requests_filtering = true
        end

        # :ids_filter_previous string may be specified in the raw SQL to allow filter previous functionality
        # to be defined explicitly in the SQL, rather than relying on the inner SQL generated by :filter_previous
        self.sql_requests_filtering = true if sql.include?(':ids_filter_previous')
        # Setup the search attribute values hash for subsequent use executing the SQL
      end

      # If :filter_previous or :ids_filter_previous is still set in the SQL
      # (typically no current user set when running a report as an admin, or no filtering ids found)
      # just remove the strings so the query doesn't fail
      sql.gsub(':filter_previous', '').gsub(':ids_filter_previous', '')
    end

    # Does the SQL definition specify a clause to filter a previous set of results?
    def filter_previous_clause?
      sql.include?(':filter_previous') || sql.include?(':ids_filter_previous')
    end

    def filtering_list
      Rails.logger.info "Reading filtering list for #{current_user}"
      return nil unless current_user

      Rails.cache.read(cache_list_key)
    end

    #
    # Filtering IDs are stored in the memcache, to simplify
    # queries to be run in future transactions.
    # Although not 100% guaranteed that the cache hasn't been purged
    # for this use it is reliable enough to handle requests
    # within reasonably short timespans
    # @return [Array | nil]
    def filtering_ids
      return nil unless current_user

      return @filtering_ids if @filtering_ids

      @filtering_ids = Rails.cache.read cache_ids_key
    end

    def write_filtering_list(list)
      Rails.logger.info "Writing filtering list for #{current_user}, #{list}"
      return nil unless current_user

      Rails.cache.write(cache_list_key, list)
    end

    def write_filtering_ids(ids)
      Rails.logger.info "Writing filtering ids for #{current_user}, #{ids}"
      return nil unless current_user

      @filtering_ids = ids
      Rails.cache.write(cache_ids_key, ids)
    end

    def cache_ids_key
      "report-results: #{current_user.id}"
    end

    def cache_list_key
      "report-list: #{current_user.id}"
    end

    #
    # Store the results to the cache
    # @param [Integer] report_id - id of the report that was run
    # @param [String] report_name - name of the report that was run
    # @param [Array{Integer}] master_ids - list of master ids returned
    # @param [Integer] results_count - total number of results returned (may not match unique list of master ids)
    # @param [Hash | nil] search_attr_values - search attribute values used for the search
    def store_results(report_id, report_name, master_ids, results_count, real_search_attr_values)
      return unless current_user

      begin
        write_filtering_ids master_ids

        # Add to the filtering list if it has been set up, otherwise initialize it empty
        list = if sql_requests_filtering
                 filtering_list || []
               else
                 []
               end

        list << {
          name: report_name,
          id: report_id,
          search_params: real_search_attr_values,
          results_length: results_count
        }

        write_filtering_list list
      rescue StandardError => e
        write_filtering_ids nil
        write_filtering_list nil
        Rails.logger.warn "Failed to write previous filtering results for #{current_user.id}\n#{e.inspect}\n#{e.backtrace.join("\n")}"
        raise FphsException, 'Failed to write previous filtering results'
      end
    end
  end
end
